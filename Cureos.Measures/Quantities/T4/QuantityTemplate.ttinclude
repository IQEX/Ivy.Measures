<#@ template hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Runtime.Remoting.Messaging" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#
    if (!string.IsNullOrWhiteSpace(ClassName)) {
        string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
        string outputFilePath = Path.Combine(templateDirectory, "T4", "Quantities.csv");
        var lines=File.ReadAllLines(outputFilePath);

        var line = lines
                    .Where(s => !String.IsNullOrWhiteSpace(s) && !s.Trim().StartsWith("//"))
                    .SingleOrDefault(s => s.Substring(0, s.IndexOf(',')).Equals(ClassName));

        if (line != null) {
            var values=line.Split(',');
            var displayName = String.IsNullOrWhiteSpace(values[1]) ? DisplayName : values[1];
            var displayNameLower = displayName.ToLowerInvariant();
            var differentiator = values[2];
            var length = Int32.Parse(values[3]);
            var mass = Int32.Parse(values[4]);
            var time = Int32.Parse(values[5]);
            var current = Int32.Parse(values[6]);
            var temperature = Int32.Parse(values[7]);
            var luminous = Int32.Parse(values[8]);
            var substance = Int32.Parse(values[9]);

            var stdUnit = values[10];
            var stdUnitSymbol = values[11];

            var loExp = Int32.Parse(values[12]);
            var hiExp = Int32.Parse(values[13]);
            
            var prefixes = new Dictionary<int, string> {
                { -24, "Yocto" }, { -21, "Zepto" }, { -18, "Atto" }, { -15, "Femto" }, { -12, "Pico" }, { -9, "Nano" }, 
                { -6, "Micro" }, { -3, "Milli" }, { -2, "Centi" }, { -1, "Deci" }, { 1, "Deka" }, { 2, "Hecto" }, 
                { 3, "Kilo" }, { 6, "Mega" }, { 9, "Giga" }, { 12, "Tera" }, { 15, "Peta" }, { 18, "Exa" }, 
                { 21, "Zetta" }, { 24, "Yotta" }};

            var selPrefixes = prefixes.Where(kv => loExp <= kv.Key && kv.Key <= hiExp).Select(kv => kv.Value).ToList();

            var unitSpecs = new List<Tuple<string, string, string>>();
            for (var i = 14; i < values.Length; i += 3) {
                var factor = "Factors." + values[i + 2].Replace("*", " * Factors.").Replace("/", " / Factors.");
                unitSpecs.Add(Tuple.Create(values[i], values[i + 1], factor));
            }
#>/*
 *  Copyright (c) 2011-2015, Cureos AB.
 *  All rights reserved.
 *  http://www.cureos.com
 *
 *	This file is part of CSUnits.
 *
 *  CSUnits is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  CSUnits is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with CSUnits. If not, see http://www.gnu.org/licenses/.
 */

/*
 * This file is auto-generated.
 */

namespace Cureos.Measures.Quantities
{
    using System;
    using System.Globalization;
    using System.Runtime.Serialization;

#if SINGLE
    using AmountType = System.Single;
#elif DECIMAL
    using AmountType = System.Decimal;
#elif DOUBLE
    using AmountType = System.Double;
#endif

    /// <summary>
    /// Implementation of the <#= displayNameLower #> quantity
    /// </summary>
    [DataContract]
    public partial struct <#= ClassName #> : IQuantity<<#= ClassName #>>, IMeasure<<#= ClassName #>>, IEquatable<<#= ClassName #>>, IComparable<<#= ClassName #>>
    {
        #region FIELDS

        // ReSharper disable once InconsistentNaming
        private static readonly IMeasureFactory<<#= ClassName #>> factory = new MeasureFactory();

        // ReSharper disable once InconsistentNaming
<#
            if (String.IsNullOrWhiteSpace(differentiator)) {
#>
        private static readonly QuantityDimension dimension = new QuantityDimension(<#= length #>, <#= mass #>, <#= time #>, <#= current #>, <#= temperature #>, <#= luminous #>, <#= substance #>);
<#
            } else if (length == 0 && mass == 0 && time == 0 && current == 0 && temperature == 0 && luminous == 0 && substance == 0) {
#>
        private static readonly QuantityDimension dimension = QuantityDimension.<#= differentiator #>;
<#
            } else {
#>
        private static readonly QuantityDimension dimension = QuantityDimension.<#= differentiator #> * new QuantityDimension(<#= length #>, <#= mass #>, <#= time #>, <#= current #>, <#= temperature #>, <#= luminous #>, <#= substance #>);
<#
            }
#>

        public static readonly Unit<<#= ClassName #>> <#= stdUnit #> = new ConstantConverterUnit<<#= ClassName #>>("<#= stdUnitSymbol #>");
<#
            if (selPrefixes.Count > 0) {
#>

<#
            }

            foreach (var selPrefix in selPrefixes) {
#>
        public static readonly Unit<<#= ClassName #>> <#= selPrefix #><#= stdUnit #> = new ConstantConverterUnit<<#= ClassName #>>(UnitPrefix.<#= selPrefix #>);
<#
            }

            if (ClassName.Equals("Temperature")) {
#>

        public static readonly Unit<Temperature> Celsius = new FunctionConverterUnit<Temperature>("°C",
                        a => a + Factors.KelvinCelsiusIntercept, a => a - Factors.KelvinCelsiusIntercept);
        public static readonly Unit<Temperature> Fahrenheit = new FunctionConverterUnit<Temperature>("°F",
                        a => (a + Factors.KelvinFahrenheitIntercept) * Factors.KelvinFahrenheitSlope,
                        a => a / Factors.KelvinFahrenheitSlope - Factors.KelvinFahrenheitIntercept);
<#
            } else {
                if (unitSpecs.Count > 0) {
#>

<#
                }

                foreach (var unitSpec in unitSpecs) {
                    var unitName = unitSpec.Item1;
                    var unitSymbol = unitSpec.Item2;
                    var factor = unitSpec.Item3;
#>
        public static readonly Unit<<#= ClassName #>> <#= unitName #> = new ConstantConverterUnit<<#= ClassName #>>("<#= unitSymbol #>", <#= factor #>);
<#
                }
            }
#>

        [DataMember]
        private readonly AmountType amount;

        #endregion

        #region CONSTRUCTORS

        /// <summary>
        /// Static constructor for defining static class properties
        /// </summary>
        static <#= ClassName #>()
        {
            Zero = new <#= ClassName #>(Constants.Zero);
            Epsilon = new <#= ClassName #>(Constants.MachineEpsilon);
        }
        
        /// <summary>
        /// Initializes a <#= displayNameLower #> object from an object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="other">Object implemeting the IMeasure&lt;<#= ClassName #>&gt; interface</param>
        public <#= ClassName #>(IMeasure<<#= ClassName #>> other)
            : this(other.StandardAmount)
        {
        }

        /// <summary>
        /// Initializes a measure to the specified amount and standard unit of the measured quantity
        /// </summary>
        /// <param name="amount">Measured amount in standard unit of the specified quantity</param>
        public <#= ClassName #>(double amount)
        {
            this.amount = (AmountType)amount;
        }

        /// <summary>
        /// Initializes a measure to the specified amount and standard unit of the measured quantity
        /// </summary>
        /// <param name="amount">Measured amount in standard unit of the specified quantity</param>
        public <#= ClassName #>(float amount)
        {
            this.amount = (AmountType)amount;
        }

        /// <summary>
        /// Initializes a measure to the specified amount and standard unit of the measured quantity
        /// </summary>
        /// <param name="amount">Measured amount in standard unit of the specified quantity</param>
        public <#= ClassName #>(decimal amount)
        {
            this.amount = (AmountType)amount;
        }

        /// <summary>
        /// Initializes a measure to the specified amount and unit
        /// </summary>
        /// <param name="amount">Measured amount</param>
        /// <param name="unit">Unit of measure</param>
        /// <exception cref="ArgumentNullException">if the specified unit is null</exception>
        public <#= ClassName #>(double amount, IUnit<<#= ClassName #>> unit)
        {
            if (unit == null) throw new ArgumentNullException("unit");
            this.amount = unit.ConvertAmountToStandardUnit((AmountType)amount);
        }

        /// <summary>
        /// Initializes a measure to the specified amount and unit
        /// </summary>
        /// <param name="amount">Measured amount</param>
        /// <param name="unit">Unit of measure</param>
        /// <exception cref="ArgumentNullException">if the specified unit is null</exception>
        public <#= ClassName #>(float amount, IUnit<<#= ClassName #>> unit)
        {
            if (unit == null) throw new ArgumentNullException("unit");
            this.amount = unit.ConvertAmountToStandardUnit((AmountType)amount);
        }

        /// <summary>
        /// Initializes a measure to the specified amount and unit
        /// </summary>
        /// <param name="amount">Measured amount</param>
        /// <param name="unit">Unit of measure</param>
        /// <exception cref="ArgumentNullException">if the specified unit is null</exception>
        public <#= ClassName #>(decimal amount, IUnit<<#= ClassName #>> unit)
        {
            if (unit == null) throw new ArgumentNullException("unit");
            this.amount = unit.ConvertAmountToStandardUnit((AmountType)amount);
        }

        #endregion

        #region Implementation of IQuantity<<#= ClassName #>>

        /// <summary>
        /// Gets the display name of the quantity
        /// </summary>
        public string DisplayName 
        { 
            get { return "<#= displayName #>"; } 
        }

        /// <summary>
        /// Gets the physical dimension of the quantity in terms of SI units
        /// </summary>
        QuantityDimension IQuantity.Dimension
        {
            get { return dimension; }
        }

        /// <summary>
        /// Gets the standard unit associated with the quantity
        /// </summary>
        IUnit IQuantity.StandardUnit
        {
            get { return this.StandardUnit; }
        }

        /// <summary>
        /// Gets the standard unit associated with the quantity
        /// </summary>
        public IUnit<<#= ClassName #>> StandardUnit
        {
            get { return <#= stdUnit #>; }
        }

        /// <summary>
        /// Gets the measure factory associated with the quantity.
        /// </summary>
        IMeasureFactory<<#= ClassName #>> IQuantity<<#= ClassName #>>.Factory
        { 
            get { return factory; }
        }

        /// <summary>
        /// Indicates whether the current object is equal to another object of the same type.
        /// </summary>
        /// <returns>
        /// true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
        /// </returns>
        /// <param name="other">An object to compare with this object.</param>
        bool IEquatable<IQuantity>.Equals(IQuantity other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }
            return other is <#= ClassName #>;
        }

        #endregion

        #region Implementation of IMeasure<<#= ClassName #>>

        /// <summary>
        /// Gets the measured amount in the <see cref="StandardUnit">standard unit of measure</see>
        /// </summary>
        public AmountType Amount
        {
            get { return this.amount; }
        }

        /// <summary>
        /// Gets the measured amount in the standard unit of measure for the <#= displayNameLower #> quantity
        /// </summary>
        public AmountType StandardAmount
        {
            get { return this.amount; }
        }

        /// <summary>
        /// Gets the unit of measure
        /// </summary>
        /// <remarks>Always return the standard unit of measure</remarks>
        IUnit IMeasure.Unit
        {
            get { return this.StandardUnit; }
        }

        /// <summary>
        /// Gets the amount of this measure in the requested unit
        /// </summary>
        /// <param name="unit">Unit to which the measured amount should be converted</param>
        /// <returns>Measured amount converted into <paramref name="unit">specified unit</paramref></returns>
        AmountType IMeasure.GetAmount(IUnit unit)
        {
            return this.GetAmount(unit as IUnit<<#= ClassName #>>);
        }

        /// <summary>
        /// Gets a new unit specific measure based on this measure but in the <paramref name="unit">specified unit</paramref>
        /// </summary>
        /// <param name="unit">Unit in which the new measure should be specified</param>
        /// <exception cref="ArgumentNullException">if specified unit is null or if specified unit is not of the <#= ClassName #> quantity.</exception>
        IMeasure IMeasure.this[IUnit unit]
        {
            get { return this[unit as IUnit<<#= ClassName #>>]; }
        }

        /// <summary>
        /// Gets the quantity-typed unit of measure
        /// </summary>
        /// <remarks>Always return the standard unit of measure</remarks>
        public IUnit<<#= ClassName #>> Unit
        {
            get { return this.StandardUnit; }
        }

        /// <summary>
        /// Gets the amount of this measure in the requested unit
        /// </summary>
        /// <param name="unit">Unit to which the measured amount should be converted</param>
        /// <returns>Measured amount converted into <paramref name="unit">specified unit</paramref></returns>
        public AmountType GetAmount(IUnit<<#= ClassName #>> unit)
        {
            if (unit == null) throw new ArgumentNullException("unit");
            return unit.ConvertStandardAmountToUnit(this.amount);
        }

        /// <summary>
        /// Gets a new unit specific measure based on this measure but in the <paramref name="unit">specified unit</paramref>
        /// </summary>
        /// <param name="unit">Unit in which the new measure should be specified</param>
        IMeasure<<#= ClassName #>> IMeasure<<#= ClassName #>>.this[IUnit<<#= ClassName #>> unit]
        {
            get { return this[unit]; }
        }

        /// <summary>
        /// Indicates whether the current object is equal to another object of the same type.
        /// </summary>
        /// <returns>
        /// true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
        /// </returns>
        /// <param name="other">An object to compare with this object.</param>
        bool IEquatable<IMeasure<<#= ClassName #>>>.Equals(IMeasure<<#= ClassName #>> other)
        {
            if (ReferenceEquals(null, other)) return false;
            return this.amount.Equals(other.StandardAmount);
        }

        /// <summary>
        /// Indicates whether the current object is equal to another object of the same type.
        /// </summary>
        /// <returns>
        /// true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
        /// </returns>
        /// <param name="other">An object to compare with this object.</param>
        bool IEquatable<IMeasure>.Equals(IMeasure other)
        {
            return this.Equals(other as IMeasure<<#= ClassName #>>);
        }

        /// <summary>
        /// Compares the current object with another object of the same type.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings:  
        ///    Value              Meaning 
        ///    Less than zero     This object is less than the <paramref name="other"/> parameter.
        ///    Zero               This object is equal to <paramref name="other"/>. 
        ///    Greater than zero  This object is greater than <paramref name="other"/>. 
        /// </returns>
        /// <param name="other">An object to compare with this object.</param>
        int IComparable<IMeasure<<#= ClassName #>>>.CompareTo(IMeasure<<#= ClassName #>> other)
        {
            if (other == null) throw new ArgumentNullException("other");
            return this.amount.CompareTo(other.StandardAmount);
        }

        /// <summary>
        /// Compares the current object with another object of the same type.
        /// </summary>
        /// <returns>
        /// A value that indicates the relative order of the objects being compared. The return value has the following meanings:  
        ///    Value              Meaning 
        ///    Less than zero     This object is less than the <paramref name="other"/> parameter.
        ///    Zero               This object is equal to <paramref name="other"/>. 
        ///    Greater than zero  This object is greater than <paramref name="other"/>. 
        /// </returns>
        /// <param name="other">An object to compare with this object.</param>
        int IComparable<IMeasure>.CompareTo(IMeasure other)
        {
            if (other == null) throw new ArgumentNullException("other");
            if (!(other.Unit.Quantity is IMeasure<<#= ClassName #>>)) throw new ArgumentException("Measures are of different quantities");
            return this.amount.CompareTo(other.StandardAmount);
        }

        #endregion

        #region Implementation of IEquatable<<#= ClassName #>>

        /// <summary>
        /// Indicates whether the current object is equal to another object of the same type.
        /// </summary>
        /// <returns>
        /// true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
        /// </returns>
        /// <param name="other">An object to compare with this object.</param>
        public bool Equals(<#= ClassName #> other)
        {
            return this.amount.Equals(other.amount);
        }

        #endregion

        #region Implementation of IComparable<<#= ClassName #>>

        /// <summary>
        /// Compares the current object with another object of the same type.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings:  
        ///    Value              Meaning 
        ///    Less than zero     This object is less than the <paramref name="other"/> parameter.
        ///    Zero               This object is equal to <paramref name="other"/>. 
        ///    Greater than zero  This object is greater than <paramref name="other"/>. 
        /// </returns>
        /// <param name="other">An object to compare with this object.</param>
        public int CompareTo(<#= ClassName #> other)
        {
            return this.amount.CompareTo(other.amount);
        }

        #endregion

        #region INDEXERS

        /// <summary>
        /// Gets a new unit preserving measure based on this measure but in the <paramref name="unit">specified unit</paramref>
        /// </summary>
        /// <param name="unit">Unit in which the new measure should be specified</param>
        public Measure<<#= ClassName #>> this[IUnit<<#= ClassName #>> unit]
        {
            get
            {
                if (unit == null) throw new ArgumentNullException("unit");
                return new Measure<<#= ClassName #>>(this.GetAmount(unit), unit);
            }
        }

        #endregion

        #region PROPERTIES
        
        public static <#= ClassName #> Zero { get; private set; }

        public static <#= ClassName #> Epsilon { get; private set; }

        #endregion
        
        #region METHODS

        /// <summary>
        /// Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
        /// </returns>
        /// <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
        /// <exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception>
        /// <filterpriority>2</filterpriority>
        public override bool Equals(object obj)
        {
            return obj is IMeasure<<#= ClassName #>> && this.Equals((IMeasure<<#= ClassName #>>)obj);
        }

        /// <summary>
        /// Serves as a hash function for a particular type. 
        /// </summary>
        /// <returns>
        /// A hash code for the current <see cref="T:System.Object"/>.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        public override int GetHashCode()
        {
            return this.amount.GetHashCode();
        }

        /// <summary>
        /// Returns the actual value with the quantity suffixed
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> containing a the actual value with the quantity symbol appended
        /// </returns>
        /// <filterpriority>2</filterpriority>
        public override string ToString()
        {
            return this.ToString("G", CultureInfo.CurrentCulture);
        }

        /// <summary>
        /// Returns the actual value in formatted form with the quantity suffixed
        /// </summary>
        /// <param name="format">Format string to display the value with</param>
        /// <returns>A <see cref="T:System.String"/> containing a the actual value in formatted form with the quantity symbol appended</returns>
        public string ToString(string format)
        {
            return this.ToString(format, CultureInfo.CurrentCulture);
        }
        
        /// <summary>
        /// Returns the actual value in formatted form with the quantity suffixed
        /// </summary>
        /// <param name="provider">Formatting provider to format the value with</param>
        /// <returns></returns>
        public string ToString(IFormatProvider provider)
        {
            return this.ToString("G", provider);
        }
        
        /// <summary>
        /// Returns the actual value in formatted form with the quantity suffixed
        /// </summary>
        /// <param name="format">Format string to display the value with</param>
        /// <param name="provider">Formatting provider to format the value with</param>
        /// <returns></returns>
        public string ToString(string format, IFormatProvider provider)
        {
            return String.Format("({0}) {1} {2}", this.DisplayName, this.amount.ToString(format, provider), this.Unit.Symbol).TrimEnd();
        }
        
        #endregion

        #region OPERATORS
<#
            if (ClassName.Equals("Number")) {
#>

        /// <summary>
        /// Casts a <#= ClassName #> object to a scalar amount
        /// </summary>
        /// <param name="measure"><#= ClassName #> object</param>
        /// <returns>Amount of <paramref name="measure"/> in unit <#= stdUnit #></returns>
        public static explicit operator AmountType(<#= ClassName #> measure)
        {
            return (AmountType)measure.amount;
        }
<#
            }
#>

        /// <summary>
        /// Casts a double value to a <#= ClassName #> object
        /// </summary>
        /// <param name="standardAmount">Standard amount</param>
        /// <returns><#= ClassName #> representation of <paramref name="standardAmount"/> in unit <#= stdUnit #></returns>
        public static explicit operator <#= ClassName #>(double standardAmount)
        {
            return new <#= ClassName #>(standardAmount);
        }

        /// <summary>
        /// Casts a float value to a <#= ClassName #> object
        /// </summary>
        /// <param name="standardAmount">Standard amount</param>
        /// <returns><#= ClassName #> representation of <paramref name="standardAmount"/> in unit <#= stdUnit #></returns>
        public static explicit operator <#= ClassName #>(float standardAmount)
        {
            return new <#= ClassName #>(standardAmount);
        }

        /// <summary>
        /// Casts a decimal value to a <#= ClassName #> object
        /// </summary>
        /// <param name="standardAmount">Standard amount</param>
        /// <returns><#= ClassName #> representation of <paramref name="standardAmount"/> in unit <#= stdUnit #></returns>
        public static explicit operator <#= ClassName #>(decimal standardAmount)
        {
            return new <#= ClassName #>(standardAmount);
        }
        
        /// <summary>
        /// Adds two measure objects provided the measured quantities are equal
        /// </summary>
        /// <param name="lhs">First measure term</param>
        /// <param name="rhs">Second measure term</param>
        /// <returns>Sum of the two measure objects in the unit of the <paramref name="lhs">left-hand side measure</paramref></returns>
        public static <#= ClassName #> operator +(<#= ClassName #> lhs,  <#= ClassName #> rhs)
        {
            return new <#= ClassName #>(lhs.amount + rhs.amount);
        }

        /// <summary>
        /// Adds two measure objects provided the measured quantities are equal
        /// </summary>
        /// <param name="lhs">First measure term</param>
        /// <param name="rhs">Second measure term (any object implementing the IMeasure interface)</param>
        /// <returns>Sum of the two measure objects in the unit of the <paramref name="lhs">left-hand side measure</paramref></returns>
        public static <#= ClassName #> operator +(<#= ClassName #> lhs, IMeasure<<#= ClassName #>> rhs)
        {
            return new <#= ClassName #>(lhs.amount + rhs.StandardAmount);
        }

        /// <summary>
        /// Subtract two measure objects of the same quantity
        /// </summary>
        /// <param name="lhs">First measure object</param>
        /// <param name="rhs">Second measure object</param>
        /// <returns>Difference of the measure objects</returns>
        public static <#= ClassName #> operator -(<#= ClassName #> lhs, <#= ClassName #> rhs)
        {
            return new <#= ClassName #>(lhs.amount - rhs.amount);
        }

        /// <summary>
        /// Subtract two measure objects of the same quantity
        /// </summary>
        /// <param name="lhs">First measure object</param>
        /// <param name="rhs">Second measure object (any object implementing the IMeasure interface)</param>
        /// <returns>Difference of the measure objects</returns>
        public static <#= ClassName #> operator -(<#= ClassName #> lhs, IMeasure<<#= ClassName #>> rhs)
        {
            return new <#= ClassName #>(lhs.amount - rhs.StandardAmount);
        }

        /// <summary>
        /// Multiply a scalar and a measure object
        /// </summary>
        /// <param name="scalar">Floating-point scalar</param>
        /// <param name="measure">Measure object</param>
        /// <returns>Product of the scalar and the measure object</returns>
        public static <#= ClassName #> operator *(double scalar, <#= ClassName #> measure)
        {
            return new <#= ClassName #>((AmountType)scalar * measure.amount);
        }

        /// <summary>
        /// Multiply a scalar and a measure object
        /// </summary>
        /// <param name="scalar">Floating-point scalar</param>
        /// <param name="measure">Measure object</param>
        /// <returns>Product of the scalar and the measure object</returns>
        public static <#= ClassName #> operator *(float scalar, <#= ClassName #> measure)
        {
            return new <#= ClassName #>((AmountType)scalar * measure.amount);
        }

        /// <summary>
        /// Multiply a scalar and a measure object
        /// </summary>
        /// <param name="scalar">Floating-point scalar</param>
        /// <param name="measure">Measure object</param>
        /// <returns>Product of the scalar and the measure object</returns>
        public static <#= ClassName #> operator *(decimal scalar, <#= ClassName #> measure)
        {
            return new <#= ClassName #>((AmountType)scalar * measure.amount);
        }

        /// <summary>
        /// Multiply a measure object and a scalar
        /// </summary>
        /// <param name="measure">Measure object</param>
        /// <param name="scalar">Floating-point scalar</param>
        /// <returns>Product of the measure object and the scalar</returns>
        public static <#= ClassName #> operator *(<#= ClassName #> measure, double scalar)
        {
            return new <#= ClassName #>(measure.amount * (AmountType)scalar);
        }

        /// <summary>
        /// Multiply a measure object and a scalar
        /// </summary>
        /// <param name="measure">Measure object</param>
        /// <param name="scalar">Floating-point scalar</param>
        /// <returns>Product of the measure object and the scalar</returns>
        public static <#= ClassName #> operator *(<#= ClassName #> measure, float scalar)
        {
            return new <#= ClassName #>(measure.amount * (AmountType)scalar);
        }

        /// <summary>
        /// Multiply a measure object and a scalar
        /// </summary>
        /// <param name="measure">Measure object</param>
        /// <param name="scalar">Floating-point scalar</param>
        /// <returns>Product of the measure object and the scalar</returns>
        public static <#= ClassName #> operator *(<#= ClassName #> measure, decimal scalar)
        {
            return new <#= ClassName #>(measure.amount * (AmountType)scalar);
        }

        /// <summary>
        /// Multiply a measure object and a number
        /// </summary>
        /// <param name="measure">Measure object</param>
        /// <param name="scalar">Floating-point number</param>
        /// <returns>Product of the measure object and the number</returns>
        public static <#= ClassName #> operator *(<#= ClassName #> measure, IMeasure<Number> scalar)
        {
            return new <#= ClassName #>(measure.amount * scalar.StandardAmount);
        }

        /// <summary>
        /// Divide a measure object with a scalar
        /// </summary>
        /// <param name="measure">measure object</param>
        /// <param name="scalar">Floating-point scalar</param>
        /// <returns>Quotient of the measure object and the scalar</returns>
        public static <#= ClassName #> operator /(<#= ClassName #> measure, double scalar)
        {
            return new <#= ClassName #>(measure.amount / (AmountType)scalar);
        }

        /// <summary>
        /// Divide a measure object with a scalar
        /// </summary>
        /// <param name="measure">measure object</param>
        /// <param name="scalar">Floating-point scalar</param>
        /// <returns>Quotient of the measure object and the scalar</returns>
        public static <#= ClassName #> operator /(<#= ClassName #> measure, float scalar)
        {
            return new <#= ClassName #>(measure.amount / (AmountType)scalar);
        }

        /// <summary>
        /// Divide a measure object with a scalar
        /// </summary>
        /// <param name="measure">measure object</param>
        /// <param name="scalar">Floating-point scalar</param>
        /// <returns>Quotient of the measure object and the scalar</returns>
        public static <#= ClassName #> operator /(<#= ClassName #> measure, decimal scalar)
        {
            return new <#= ClassName #>(measure.amount / (AmountType)scalar);
        }

<#
            if (!ClassName.Equals("Number")) {
#>
        /// <summary>
        /// Divide a measure object with a number
        /// </summary>
        /// <param name="measure">measure object</param>
        /// <param name="scalar">Floating-point number</param>
        /// <returns>Quotient of the measure object and the number</returns>
        public static <#= ClassName #> operator /(<#= ClassName #> measure, IMeasure<Number> scalar)
        {
            return new <#= ClassName #>(measure.amount / scalar.StandardAmount);
        }

<#
            }
#>
        /// <summary>
        /// Divide a measure object with a measure object of the same quantity
        /// </summary>
        /// <param name="dividend">Dividend of specific quantity</param>
        /// <param name="divisor">Divisor of same quantity as dividend</param>
        /// <returns>Quotient of the two measure objects</returns>
        public static Number operator /(<#= ClassName #> dividend, <#= ClassName #> divisor)
        {
            return new Number(dividend.amount / divisor.amount);
        }

        /// <summary>
        /// Divide a measure object with a measure object of the same quantity
        /// </summary>
        /// <param name="dividend">Dividend of specific quantity</param>
        /// <param name="divisor">Divisor of same quantity as dividend</param>
        /// <returns>Quotient of the two measure objects</returns>
        public static Number operator /(<#= ClassName #> dividend, IMeasure<<#= ClassName #>> divisor)
        {
            return new Number(dividend.amount / divisor.StandardAmount);
        }

        /// <summary>
        /// Less than operator for measure objects
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if first measure object is less than second measure object; false otherwise</returns>
        public static bool operator <(<#= ClassName #> lhs, <#= ClassName #> rhs)
        {
            return lhs.amount < rhs.amount;
        }

        /// <summary>
        /// Less than operator for measure objects, where right-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <returns>true if first measure object is less than second measure object; false otherwise</returns>
        public static bool operator <(<#= ClassName #> lhs, IMeasure<<#= ClassName #>> rhs)
        {
            return lhs.amount < rhs.StandardAmount;
        }

        /// <summary>
        /// Less than operator for measure objects, where left-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if first measure object is less than second measure object; false otherwise</returns>
        public static bool operator <(IMeasure<<#= ClassName #>> lhs, <#= ClassName #> rhs)
        {
            return lhs.StandardAmount < rhs.amount;
        }

        /// <summary>
        /// Greater than operator for measure objects
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if first measure object is greater than second measure object; false otherwise</returns>
        public static bool operator >(<#= ClassName #> lhs, <#= ClassName #> rhs)
        {
            return lhs.amount > rhs.amount;
        }

        /// <summary>
        /// Greater than operator for measure objects, where right-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <returns>true if first measure object is greater than second measure object; false otherwise</returns>
        public static bool operator >(<#= ClassName #> lhs, IMeasure<<#= ClassName #>> rhs)
        {
            return lhs.amount > rhs.StandardAmount;
        }

        /// <summary>
        /// Greater than operator for measure objects, where left-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if first measure object is greater than second measure object; false otherwise</returns>
        public static bool operator >(IMeasure<<#= ClassName #>> lhs, <#= ClassName #> rhs)
        {
            return lhs.StandardAmount > rhs.amount;
        }

        /// <summary>
        /// Less than or equal to operator for measure objects
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if first measure object is less than or equal to second measure object; false otherwise</returns>
        public static bool operator <=(<#= ClassName #> lhs, <#= ClassName #> rhs)
        {
            return lhs.amount <= rhs.amount;
        }

        /// <summary>
        /// Less than or equal to operator for measure objects, where right-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <returns>true if first measure object is less than or equal to second measure object; false otherwise</returns>
        public static bool operator <=(<#= ClassName #> lhs, IMeasure<<#= ClassName #>> rhs)
        {
            return lhs.amount <= rhs.StandardAmount;
        }

        /// <summary>
        /// Less than or equal to operator for measure objects, where left-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if first measure object is less than or equal to second measure object; false otherwise</returns>
        public static bool operator <=(IMeasure<<#= ClassName #>> lhs, <#= ClassName #> rhs)
        {
            return lhs.StandardAmount <= rhs.amount;
        }

        /// <summary>
        /// Greater than or equal to operator for measure objects
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if first measure object is greater than or equal to second measure object; false otherwise</returns>
        public static bool operator >=(<#= ClassName #> lhs, <#= ClassName #> rhs)
        {
            return lhs.amount >= rhs.amount;
        }

        /// <summary>
        /// Greater than or equal to operator for measure objects, where right-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <returns>true if first measure object is greater than or equal to second measure object; false otherwise</returns>
        public static bool operator >=(<#= ClassName #> lhs, IMeasure<<#= ClassName #>> rhs)
        {
            return lhs.amount >= rhs.StandardAmount;
        }

        /// <summary>
        /// Greater than or equal to operator for measure objects, where left-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if first measure object is greater than or equal to second measure object; false otherwise</returns>
        public static bool operator >=(IMeasure<<#= ClassName #>> lhs, <#= ClassName #> rhs)
        {
            return lhs.StandardAmount >= rhs.amount;
        }

        /// <summary>
        /// Equality operator for measure objects
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if the two measure objects are equal; false otherwise</returns>
        public static bool operator ==(<#= ClassName #> lhs, <#= ClassName #> rhs)
        {
            return lhs.amount == rhs.amount;
        }

        /// <summary>
        /// Equality operator for measure objects, where right-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <returns>true if the two measure objects are equal; false otherwise</returns>
        public static bool operator ==(<#= ClassName #> lhs, IMeasure<<#= ClassName #>> rhs)
        {
            return lhs.amount == rhs.StandardAmount;
        }

        /// <summary>
        /// Equality operator for measure objects, where left-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if the two measure objects are equal; false otherwise</returns>
        public static bool operator ==(IMeasure<<#= ClassName #>> lhs, <#= ClassName #> rhs)
        {
            return lhs.StandardAmount == rhs.amount;
        }

        /// <summary>
        /// Inequality operator for measure objects
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if the two measure objects are not equal; false if they are equal</returns>
        public static bool operator !=(<#= ClassName #> lhs, <#= ClassName #> rhs)
        {
            return lhs.amount != rhs.amount;
        }

        /// <summary>
        /// Inequality operator for measure objects, where right-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object</param>
        /// <param name="rhs">Second object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <returns>true if the two measure objects are not equal; false if they are equal</returns>
        public static bool operator !=(<#= ClassName #> lhs, IMeasure<<#= ClassName #>> rhs)
        {
            return lhs.amount != rhs.StandardAmount;
        }

        /// <summary>
        /// Inequality operator for measure objects, where left-hand side may be any object implementing the IMeasure&lt;<#= ClassName #>&gt; interface
        /// </summary>
        /// <param name="lhs">First object (any object implementing IMeasure&lt;<#= ClassName #>&gt; interface)</param>
        /// <param name="rhs">Second object</param>
        /// <returns>true if the two measure objects are not equal; false if they are equal</returns>
        public static bool operator !=(IMeasure<<#= ClassName #>> lhs, <#= ClassName #> rhs)
        {
            return lhs.StandardAmount != rhs.amount;
        }

        #endregion

        #region Private class implementation of IMeasureFactory<<#= ClassName #>>

        private class MeasureFactory : IMeasureFactory<<#= ClassName #>>
        {
            /// <summary>
            /// Creates a new standard unit measure at the specified <paramref name="amount"/>.
            /// </summary>
            /// <param name="amount">Amount.</param>
            /// <returns>Standard unit measure at the specified <paramref name="amount"/>.</returns>
            public <#= ClassName #> New(double amount)
            {
                return new <#= ClassName #>(amount);
            }

            /// <summary>
            /// Creates a new standard unit measure.
            /// </summary>
            /// <param name="amount">Amount.</param>
            /// <param name="unit">Unit.</param>
            /// <returns>Standard unit measure.</returns>
            public <#= ClassName #> New(double amount, IUnit<<#= ClassName #>> unit)
            {
                return new <#= ClassName #>(amount, unit);
            }

            /// <summary>
            /// Creates a new standard unit measure at the specified <paramref name="amount"/>.
            /// </summary>
            /// <param name="amount">Amount.</param>
            /// <returns>Standard unit measure at the specified <paramref name="amount"/>.</returns>
            public <#= ClassName #> New(float amount)
            {
                return new <#= ClassName #>(amount);
            }

            /// <summary>
            /// Creates a new standard unit measure.
            /// </summary>
            /// <param name="amount">Amount.</param>
            /// <param name="unit">Unit.</param>
            /// <returns>Standard unit measure.</returns>
            public <#= ClassName #> New(float amount, IUnit<<#= ClassName #>> unit)
            {
                return new <#= ClassName #>(amount, unit);
            }

            /// <summary>
            /// Creates a new standard unit measure at the specified <paramref name="amount"/>.
            /// </summary>
            /// <param name="amount">Amount.</param>
            /// <returns>Standard unit measure at the specified <paramref name="amount"/>.</returns>
            public <#= ClassName #> New(decimal amount)
            {
                return new <#= ClassName #>(amount);
            }

            /// <summary>
            /// Creates a new standard unit measure.
            /// </summary>
            /// <param name="amount">Amount.</param>
            /// <param name="unit">Unit.</param>
            /// <returns>Standard unit measure.</returns>
            public <#= ClassName #> New(decimal amount, IUnit<<#= ClassName #>> unit)
            {
                return new <#= ClassName #>(amount, unit);
            }

            /// <summary>
            /// Creates a new measure from the specified <paramref name="amount"/> and <paramref name="unit"/>.
            /// </summary>
            /// <param name="amount">Amount.</param>
            /// <param name="unit">Unit.</param>
            /// <returns>Measure from the specified <paramref name="amount"/> and <paramref name="unit"/>.</returns>
            public IMeasure<<#= ClassName #>> NewPreserveUnit(double amount, IUnit<<#= ClassName #>> unit)
            {
                return new Measure<<#= ClassName #>>(amount, unit);
            }

            /// <summary>
            /// Creates a new measure from the specified <paramref name="amount"/> and <paramref name="unit"/>.
            /// </summary>
            /// <param name="amount">Amount.</param>
            /// <param name="unit">Unit.</param>
            /// <returns>Measure from the specified <paramref name="amount"/> and <paramref name="unit"/>.</returns>
            public IMeasure<<#= ClassName #>> NewPreserveUnit(float amount, IUnit<<#= ClassName #>> unit)
            {
                return new Measure<<#= ClassName #>>(amount, unit);
            }

            /// <summary>
            /// Creates a new measure from the specified <paramref name="amount"/> and <paramref name="unit"/>.
            /// </summary>
            /// <param name="amount">Amount.</param>
            /// <param name="unit">Unit.</param>
            /// <returns>Measure from the specified <paramref name="amount"/> and <paramref name="unit"/>.</returns>
            public IMeasure<<#= ClassName #>> NewPreserveUnit(decimal amount, IUnit<<#= ClassName #>> unit)
            {
                return new Measure<<#= ClassName #>>(amount, unit);
            }
        }

        #endregion
    }
}
<#		}
    }#>
<#+
    string ClassName
    {
        get { return (string)CallContext.GetData("MyParameter"); }
    }

    string DisplayName
    {
        get {
            var className = ClassName;
            var displayName = className.Substring(0, 1);
            for (var i = 1; i < className.Length; i++) {
                if (Char.IsUpper(className[i])) displayName += " ";
                displayName += className[i];
            }
            return displayName;
        }
    }
#>